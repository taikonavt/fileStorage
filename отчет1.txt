// CLIENT

import io.netty.handler.codec.serialization.ObjectEncoderOutputStream;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.Socket;

public class Main extends Application implements ServerConst, Server_API{
    Socket socket = null;
    ObjectEncoderOutputStream oeos = null;
    ObjectInputStream ois;
    Packet packet;
    Packet reply;
    private boolean isConnected = false;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception{
        packet = new Packet();

        // открываю соединение с сервером, посылаю echo сообщение, сервер присылает ответ
        if (socket == null || socket.isClosed()) {
            try {
                socket = new Socket(SERVER_URL, PORT);
                oeos = new ObjectEncoderOutputStream(socket.getOutputStream());
                packet.setCmd(ECHO);
                oeos.writeObject(packet);
                oeos.flush();
                isConnected = true;
            } catch (IOException e){
                e.printStackTrace();
            }
        }

        // запускаю графическую оболочку, отправляю в controller экземпляр main
        FXMLLoader loader = new FXMLLoader(getClass().getResource("sample.fxml"));
        Parent root = loader.load();
        Controller controller = loader.getController();
        controller.setMain(this);

        primaryStage.setTitle("GeekCloud Client");
        primaryStage.setScene(new Scene(root, 600.0D, 600.0D));
        primaryStage.show();

        // в новом потоке слушаю входящие сообщения
        new Thread(()->{
            try {
                while (isConnected){
        // !!! поток зависает на этом месте и echo сообщение не читает
                    ois = new ObjectInputStream(socket.getInputStream());
                    System.out.println(ois.available());
                    if (ois.available() > 0) {
                        reply = (Packet) ois.readObject();
                        System.out.println(reply.getCmd());
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }).start();
    }

    @Override
    public void stop() throws Exception {
        super.stop();
        isConnected = false;
        oeos.close();
        ois.close();
        socket.close();
    }

    // срабатывает при нажатии кнопки "Авторизоваться"
    public void auth(String login, String pass){
        packet.setLogin(login);
        packet.setPass(pass);
        packet.setCmd(AUTH);
        try {
            oeos.writeObject(packet);
            oeos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


import javafx.fxml.FXML;
import javafx.scene.control.ListView;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;

public class Controller {
    private Main main;

    @FXML ProgressBar operationProgress;
    @FXML HBox authPanel;
    @FXML TextField loginField;
    @FXML TextField passField;
    @FXML ListView localList;
    @FXML HBox actionPanel1;
    @FXML ListView cloudList;
    @FXML HBox actionPanel2;

    public void onAuthBtnClick(){
        String login = loginField.getText();
        String pass = passField.getText();

        main.auth(login, pass);
    }

    public void setMain(Main main){
        this.main = main;
    }
}


// SERVER

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;

public class Server implements ServerConst {
    private static final int MAX_OBJ_SIZE = 1024 * 1024 * 100;

    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class) // (3)
                    .handler(new LoggingHandler(LogLevel.INFO))
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(
                                    new ObjectDecoder(MAX_OBJ_SIZE, ClassResolvers.cacheDisabled(null)),
                                    new ServerHandler());
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);

            ChannelFuture f = b.bind(PORT).sync();

            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new Server().run();
    }
}


import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

public class ServerHandler extends ChannelInboundHandlerAdapter
                    implements Server_API{

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        Packet packet = (Packet)msg;
        String cmd = packet.getCmd();

        // echo отклик при открытии соединения
        if (cmd.startsWith(ECHO)){
            System.out.println(cmd);
            Packet reply = new Packet();
            reply.setCmd(ECHO);
            ctx.write(reply);
            ctx.flush();
            System.out.println("echo has been send");
        }
        // аутентификация
        if (cmd.startsWith(AUTH)){
            AuthService.authenticate(packet.getLogin(), packet.getPass());
            Packet reply = new Packet();
            if (AuthService.isAuthorized(packet.getLogin())){
                reply.setCmd(AUTH_SUCCESSFUl);
                ctx.write(reply);
                ctx.flush();
            } else {
                reply.setCmd(AUTH_DENIED);
                ctx.write(reply);
                ctx.flush();
            }
        }

        if (AuthService.isAuthorized(packet.getLogin())){
        }
    }
}

// класс для работы с аутентификацией через БД
public class AuthService {
    private static AuthService instance;
    private static boolean authorized = false;

    public static AuthService getInstance(){
        if (instance == null){
            instance = new AuthService();
        }
        return instance;
    }

    public static boolean isAuthorized(String login) {
        return authorized;
    }

    public static boolean authenticate(String login, String pass){
        //TODO auth;
        authorized = true;
        return true;
    }

    public static void quit(){
        authorized = false;
    }
}


//COMMON

import java.io.Serializable;

// пакет для передачи данных
public class Packet implements Serializable{
    private static final long serialVersionUID = 5193392663743561680L;
    private String cmd; // служебные команды
    private String login;
    private String pass;

    public void setCmd(String cmd){
        this.cmd = cmd;
    }

    public String getCmd(){
        return cmd;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getLogin() {
        return login;
    }

    public void setPass(String pass) {
        this.pass = pass;
    }

    public String getPass() {
        return pass;
    }
}

// класс со служебными командами
public interface Server_API {
    String CLOSE_CONNECTION = "/quit";
    String AUTH = "/auth";
    String AUTH_SUCCESSFUl = "/authok";
    String AUTH_DENIED = "/authdenied";
    String ECHO = "/echo";
}


// класс с константами
public interface ServerConst {
    int PORT = 8189;
    String SERVER_URL = "localhost";
}